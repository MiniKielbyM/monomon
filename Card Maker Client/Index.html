<!DOCTYPE html>
<html>

<head>
    <!-- Load Blockly core -->
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <!-- Load the default blocks -->
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <!-- Load the JavaScript generator -->
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <!-- Load messages -->
    <script src="https://unpkg.com/blockly/msg/en.js"></script>
    <!-- Prism CSS -->
    <link href="https://unpkg.com/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
    <!-- Prism JS -->
    <script src="https://unpkg.com/prismjs/prism.js"></script>
    <script src="https://unpkg.com/prismjs/components/prism-javascript.js"></script>
    <!-- Bootstrap CSS for icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
        crossorigin="anonymous"></script>
    <!-- Pokemon List -->
    <script src="./WebPokemonList.js"></script>
    <!-- Custom CSS -->
    <style>
        /* copy button */
        pre:has(code) svg {
            position: sticky;
            float: right;
            cursor: pointer;
            z-index: 10;
            right: 1rem;
            top: 1rem;
        }

        /* code block */
        pre:has(code) {
            position: relative;
            overflow-y: auto;
            width: 200px;
            background-color: black;
            color: white;
            padding-inline: 0.25rem;
            padding-block-end: 1rem;
        }
    </style>
    <title>Card Maker</title>
</head>

<body style="margin:0; overflow: hidden;">
    <!-- Blockly workspace -->
    <div id="blocklyDiv" style="height: 60vh; width: 75vw; padding: 0px; margin: 0px;"></div>
    <div style="height: 31.5vh; width: 100vw; overflow:auto; padding: 0px; margin: 0px; position: absolute; bottom: 0; left: 0; background-color: #2d2d2d; ">
        <pre style="margin:0;padding:0;height:100%;width:100%;">
            <svg xmlns="http://www.w3.org/2000/svg" width="1.5rem" height="1.5rem" fill="white" class="bi bi-clipboard" viewBox="0 0 16 16" onclick="
                const codeEl = document.getElementById('output');
                if (!codeEl) return;
                const text = codeEl.textContent || '';
                navigator.clipboard.writeText(text).then(() => {
                    // Show tooltip on success
                    const tooltip = bootstrap.Tooltip.getOrCreateInstance(this, {
                        title: 'Copied!',
                        placement: 'top',
                        trigger: 'manual'
                    });
                    tooltip.show();
                    setTimeout(() => tooltip.hide(), 1000);
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                });
            ">
                <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/>
                <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"/>
            </svg>
            <code class="language-javascript" id="output" style="margin:0;padding: 0; padding-left:1vw;display:block;height: 100%;width:99%;">
                
            </code>

        </pre>
    </div>



    <script>
        // Define custom metadata blocks in JSON
        const definitions = Blockly.common.createBlockDefinitionsFromJsonArray([
            {
                type: 'meta_header',
                message0: 'METADATA\n\n',
                message1: `Display Name: %1\n`,
                args1: [
                    { type: 'field_input', name: 'DISPLAY_NAME', text: 'New Card' },
                ],
                message2: 'Pokemon: %1',
                args2: [
                    {
                        "type": "field_dropdown",
                        "name": "POKEMON",
                        "options": [...Pokemon.map(name => [name, name])]
                    },
                ],
                message3: 'Type: %1',
                args3: [
                    {
                        "type": "field_dropdown",
                        "name": "TYPE",
                        "options": [
                            ["Grass", "grass"], ["Fire", "fire"], ["Water", "water"],
                            ["Lightning", "lightning"], ["Fighting", "fighting"],
                            ["Psychic", "psychic"], ["Dark", "dark"], ["Metal", "metal"],
                            ["Fairy", "fairy"], ["Colorless", "colorless"]
                        ]
                    }
                ],
                message4: 'HP: %1',
                args4: [
                    { type: 'field_number', name: 'HP', value: 60, min: 0, precision: 10 },
                ],
                colour: "#ff6a00",
                nextStatement: "metadata",
            },
            {
                type: 'meta_weakness',
                message0: 'Weakness %1',
                args0: [
                    {
                        "type": "field_dropdown",
                        "name": "TYPE",
                        "options": [
                            ["Grass", "grass"], ["Fire", "fire"], ["Water", "water"],
                            ["Lightning", "lightning"], ["Fighting", "fighting"],
                            ["Psychic", "psychic"], ["Dark", "dark"], ["Metal", "metal"],
                            ["Fairy", "fairy"], ["Colorless", "colorless"]
                        ]
                    }
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata",
            },
            {
                type: 'meta_resistance',
                message0: 'Resistance %1',
                args0: [
                    {
                        "type": "field_dropdown",
                        "name": "TYPE",
                        "options": [
                            ["Grass", "grass"], ["Fire", "fire"], ["Water", "water"],
                            ["Lightning", "lightning"], ["Fighting", "fighting"],
                            ["Psychic", "psychic"], ["Dark", "dark"], ["Metal", "metal"],
                            ["Fairy", "fairy"], ["Colorless", "colorless"]
                        ]
                    }
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata",
            },
            {
                type: `meta_evolution`,
                message0: 'Evolves from: %1',
                args0: [
                    {
                        "type": "field_dropdown",
                        "name": "POKEMON",
                        "options": [...Pokemon.map(name => [name, name])]
                    }
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata",
            },
            {
                type: `meta_can_evolve`,
                message0: 'Can evolve? %1',
                args0: [
                    { "type": "field_checkbox", "name": "CAN_EVOLVE", "checked": true }
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata",
            },
            {
                type: `meta_prize_cards`,
                message0: 'Prize cards: %1',
                args0: [
                    { type: 'field_number', name: 'PRIZE_CARDS', value: 1, min: 0, precision: 1 },
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata",
            },
            // JSON mutator blocks
            {
                type: "metadata_resistance",
                message0: "Retreat Cost: %1",
                args0: [
                    { type: 'field_number', name: 'RETREAT_COST', value: 1, min: 0, precision: 1 },
                ],
                colour: "#ff6a00",
                nextStatement: "metadata",
                previousStatement: "metadata",
            },
            {
                type: "metadata_card_modifier",
                message0: "Card Modifier: %1",
                args0: [
                    {
                        "type": "field_dropdown",
                        "name": "CARD_MOD",
                        "options": [
                            ["none", "base"], ["Break", "break"], ["EX", "ex"], ["MEGA EX", "megaex"],
                            ["GX", "gx"], ["Tag-Team GX", "gxtagteam"], ["V", "v"], ["VMAX", "vmax"]
                        ]
                    }
                ],
                colour: "#ff6a00",
                previousStatement: "metadata",
                nextStatement: "metadata"
            }
        ]);

        // Register block definitions
        Blockly.common.defineBlocks(definitions);

        // Generators
        const javascriptGenerator = Blockly.JavaScript;

        javascriptGenerator.forBlock['meta_header'] = () => '';
        javascriptGenerator.forBlock['meta_weakness'] = b =>
            `this.weakness = PokemonType.${b.getFieldValue('TYPE').toUpperCase()};`;
        javascriptGenerator.forBlock['meta_resistance'] = b =>
            `this.resistance = PokemonType.${b.getFieldValue('TYPE').toUpperCase()};`;
        javascriptGenerator.forBlock['meta_evolution'] = b =>
            `this.evolvesFrom = '${b.getFieldValue('POKEMON')}';`;
        javascriptGenerator.forBlock['meta_can_evolve'] = b =>
            `this.canEvolve = ${b.getFieldValue('CAN_EVOLVE') === 'TRUE'};`;
        javascriptGenerator.forBlock['meta_prize_cards'] = b =>
            `this.prizeCards = ${b.getFieldValue('PRIZE_CARDS')};`;
        javascriptGenerator.forBlock['metadata_resistance'] = function (block) {

            return `this.retreatCost = ${block.getFieldValue('RETREAT_COST')};`;
        };
        javascriptGenerator.forBlock['metadata_card_modifier'] = b =>
            `this.cardMod = CardModifiers.${b.getFieldValue('CARD_MOD').toUpperCase()};`;
        // Inject Blockly
        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: `<xml xmlns="https://developers.google.com/blockly/xml">
            <category name="MetaData" colour="#ff6a00">
                <block type="meta_header"></block>
                <block type="meta_weakness"></block>
                <block type="meta_resistance"></block>
                <block type="meta_evolution"></block>
                <block type="meta_can_evolve"></block>
                <block type="meta_prize_cards"></block>
                <block type="metadata_resistance"></block>
                <block type="metadata_card_modifier"></block>
            </category>
            <category name="Abilities" colour="#5b80a5">
            </category>
        </xml>`,
            theme: Blockly.Themes.Dark,
            trashcan: true,
            move: { scrollbars: false, drag: false, wheel: false },
            zoom: { controls: false, wheel: false, startScale: 0.75, maxScale: 0.75, minScale: 0.75, scaleSpeed: 0 },
            renderer: 'Zelos'
        });

        function toClassName(str) {
            if (!str) return "UnnamedCard";
            str = str.trim().replace(/[^a-zA-Z0-9]+/g, " ");
            str = str.split(" ").filter(Boolean)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join("");
            if (!/^[A-Za-z_]/.test(str)) str = "_" + str;
            return str || "UnnamedClass";
        }

        function indentCode(code, spaces = 8) {
            return code
                .split("\n")
                .filter(line => line.trim() !== "")
                .map(line => " ".repeat(spaces) + line)
                .join("\n");
        }

        /**
         * Collects code for each metadata block after startBlock.
         * Important: calls the block-specific generator function directly to avoid Blockly's
         * default chaining (which uses scrub_ and appends subsequent blocks).
         * Falls back to a safe extraction from blockToCode() if no direct generator exists.
         */
        function collectMetadataCode(startBlock, generator) {
            let code = "";
            let current = startBlock.nextConnection ? startBlock.nextConnection.targetBlock() : null;
            while (current) {
                let blockCode = "";

                // Prefer direct per-block generator (this returns only this block's code)
                const genFunc = generator.forBlock && generator.forBlock[current.type];
                if (typeof genFunc === "function") {
                    try {
                        blockCode = genFunc(current, generator);
                    } catch (e) {
                        // If direct call fails, fallback to blockToCode below
                        blockCode = "";
                    }
                }

                // Fallback: try to use blockToCode but isolate just this block's contribution.
                if (!blockCode) {
                    let full = generator.blockToCode(current) || "";
                    // blockToCode often includes code for next blocks via scrub_. To avoid dupes,
                    // take only the first meaningful line if full contains multiple lines.
                    if (typeof full === "string" && full.indexOf("\n") !== -1) {
                        const lines = full.split("\n").map(l => l.trim()).filter(Boolean);
                        // If the block produces a single-line statement, use that; otherwise use the first non-empty line.
                        blockCode = lines.length ? lines[0] : "";
                    } else {
                        blockCode = (Array.isArray(full) ? full[0] : full) || "";
                    }
                }

                // If generator returned array like [code, order], get first element
                if (Array.isArray(blockCode)) blockCode = blockCode[0];

                blockCode = (blockCode || "").toString().trim();
                if (blockCode !== "") {
                    code += blockCode + "\n"; // ensure exactly one newline per block
                }

                // Move to next connected block in the chain
                current = current.nextConnection ? current.nextConnection.targetBlock() : null;
            }
            return code;
        }

        // Function called when workspace changes
        function runCode() {
            javascriptGenerator.init(workspace);

            const metaHeaderBlock = workspace.getAllBlocks(false).find(b => b.type === 'meta_header');
            if (!metaHeaderBlock) return;

            // collect and indent metadata code
            let metaCode = collectMetadataCode(metaHeaderBlock, javascriptGenerator);
            metaCode = indentCode(metaCode, 8);

            let code = `import Card from "./card.js";
import enums from "./enums.js";
const { PokemonType, CardModifiers } = enums;
class ${toClassName(metaHeaderBlock.getFieldValue("DISPLAY_NAME"))} extends Card {
    constructor() {
        super(
            '${metaHeaderBlock.getFieldValue("DISPLAY_NAME") || "New Card"}',
            PokemonType.${metaHeaderBlock.getFieldValue("TYPE").toUpperCase() || "COLORLESS"},
            ${metaHeaderBlock.getFieldValue("HP") || 0},
            '${metaHeaderBlock.getFieldValue("POKEMON") || "Unknown"}',
            null,
            true,
            null,
            null,
            0,
            1,
            CardModifiers.BASE
        );
${metaCode}
    }
}
export default ${toClassName(metaHeaderBlock.getFieldValue("DISPLAY_NAME"))};`;

            javascriptGenerator.finish(code);

            const codeEl = document.getElementById('output');
            codeEl.textContent = code;
            Prism.highlightElement(codeEl);
        }

        workspace.addChangeListener(function (event) {
            if (event.type === Blockly.Events.BLOCK_CREATE) {
                const blocks = workspace.getAllBlocks(false);
                const metaTypes = ['meta_header', 'meta_weakness', 'meta_resistance', 'meta_evolution'];
                for (const type of metaTypes) {
                    const metaBlocks = blocks.filter(b => b.type === type);
                    const maxAllowed = 1;
                    if (metaBlocks.length > maxAllowed) {
                        // Dispose the newest block of this type
                        const newBlockId = event.ids.find(id => {
                            const block = workspace.getBlockById(id);
                            return block && block.type === type;
                        });
                        const newBlock = newBlockId ? workspace.getBlockById(newBlockId) : null;
                        if (newBlock) newBlock.dispose(false, true);
                    }
                }
            }
            if (!event.isUiEvent) {
                runCode();
            }
        });

    </script>
</body>

</html>