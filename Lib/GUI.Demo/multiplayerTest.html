<!DOCTYPE html>
<html>

<head>
    <title>Pokemon TCG - Multiplayer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="/Lib/GUI.Demo/BoardLayout.css">
    <style>
        /* Connection status styles */
        #connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 1000;
        }
        
        .status-connected { background-color: #4CAF50; }
        .status-connecting { background-color: #FF9800; }
        .status-disconnected { background-color: #f44336; }
        .status-waiting { background-color: #2196F3; }
        
        /* Game messages */
        #game-messages {
            position: fixed;
            top: 60px;
            left: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            z-index: 1000;
            display: none;
        }
        
        /* Player info */
        #player-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 5px;
            z-index: 1000;
        }
        
        #turn-status {
            font-weight: bold;
            padding: 5px;
            border-radius: 3px;
            margin-top: 5px;
        }
        
        .your-turn { 
            background-color: #4CAF50; 
            color: white;
        }
        
        .opponent-turn { 
            background-color: #FF9800; 
            color: white;
        }
        
        /* Username input */
        #username-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        #username-form {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
        }
        
        #username-input {
            padding: 10px;
            margin: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #join-button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        #join-button:hover {
            background: #45a049;
        }
        
        /* Deck count display */
        .deck-count {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .deck {
            position: relative;
        }
    </style>
</head>

<body>
    <!-- Username Modal -->
    <div id="username-modal">
        <div id="username-form">
            <h2>Join Pokemon TCG Game</h2>
            <input type="text" id="username-input" placeholder="Enter your username" maxlength="20">
            <br>
            <button id="join-button">Join Game</button>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" class="status-disconnected">
        Disconnected
    </div>
    
    <!-- Game Messages -->
    <div id="game-messages"></div>
    
    <!-- Player Info -->
    <div id="player-info">
        <div>Player: <span id="current-username">-</span></div>
        <div>Player Number: <span id="player-number">-</span></div>
        <div>Opponent: <span id="opponent-name">-</span></div>
        <div>Turn: <span id="turn-number">-</span></div>
        <div id="turn-status">Waiting for game to start...</div>
    </div>

    <div id="aspect-box">
        <div id="sixteenbynine">

            <div id="opponent-zone">
                <div class="bench">
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                </div>
                <div class="card active opp empty"></div>
                <div class="card lost-zone opp empty"></div>
                <div class="card discard opp empty"></div>
                <div class="deck opp"></div>
                <div class="prize-zone one">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
                <div class="prize-zone two">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
                <div class="prize-zone three">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
            </div>
            <div id="player-zone">
                <div id="ActivePokemon" class="card active player empty"></div>
                <div class="bench">
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                </div>
                <div class="hand-outer">
                    <div class="hand-inner">
                        <div id="PlayerHand" class="hand">
                        </div>
                    </div>
                </div>
                <div class="prize-zone one">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="prize-zone two">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="prize-zone three">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="deck player"></div>
                <div class="card discard player empty"></div>
                <div class="card lost-zone player empty"></div>
            </div>

        </div>
    </div>
    
    <script type="module">
        import Client from '/Lib/client.js';
        import Game from '/Lib/game.js';
        // Deck import removed - server manages all deck state
        import GUIHookUtils from '/Lib/guiHookUtils.js';
        import WebSocketClient from '/Lib/webSocketClient.js';
        import enums from '/Lib/enums.js';
        // Card imports removed - server creates all card instances

        const { PokemonType, CardModifiers } = enums;
        // Card destructuring removed - server provides all card data

        // Initialize WebSocket client and GUI
        const wsClient = new WebSocketClient();
        const guiHook = new GUIHookUtils(document.body, wsClient);
        
        // Make wsClient available globally for attack functions
        window.wsClient = wsClient;
        
        // UI Elements
        const usernameModal = document.getElementById('username-modal');
        const usernameInput = document.getElementById('username-input');
        const joinButton = document.getElementById('join-button');
        const connectionStatus = document.getElementById('connection-status');
        const gameMessages = document.getElementById('game-messages');
        const currentUsernameSpan = document.getElementById('current-username');
        const playerNumberSpan = document.getElementById('player-number');
        const opponentNameSpan = document.getElementById('opponent-name');
        const turnNumberSpan = document.getElementById('turn-number');
        const turnStatusDiv = document.getElementById('turn-status');
        
        let currentUsername = '';
        let playerNumber = 0;
        let currentTurn = 0;
        let isMyTurn = false;
        let player1, player2, game;
        
        // Update connection status
        function updateConnectionStatus(status, message) {
            connectionStatus.className = `status-${status}`;
            connectionStatus.textContent = message;
        }
        
        // Initialize deck count displays
        function initializeDeckCounts() {
            const playerDeck = document.querySelector('.deck.player');
            const opponentDeck = document.querySelector('.deck.opp');
            
            if (playerDeck && !playerDeck.querySelector('.deck-count')) {
                const playerDeckCount = document.createElement('div');
                playerDeckCount.className = 'deck-count';
                playerDeckCount.id = 'player-deck-count';
                playerDeckCount.textContent = '60';
                playerDeck.appendChild(playerDeckCount);
            }
            
            if (opponentDeck && !opponentDeck.querySelector('.deck-count')) {
                const opponentDeckCount = document.createElement('div');
                opponentDeckCount.className = 'deck-count';
                opponentDeckCount.id = 'opponent-deck-count';
                opponentDeckCount.textContent = '60';
                opponentDeck.appendChild(opponentDeckCount);
            }
        }
        
        // Update deck count displays
        function updateDeckCounts(gameState) {
            if (!gameState) return;
            
            const playerDeckCount = document.getElementById('player-deck-count');
            const opponentDeckCount = document.getElementById('opponent-deck-count');
            
            if (playerDeckCount && gameState.yourState) {
                const deckCount = gameState.yourState.deckCount || (gameState.yourState.deck ? gameState.yourState.deck.length : 0);
                playerDeckCount.textContent = deckCount;
                
                // Change color based on deck count
                if (deckCount === 0) {
                    playerDeckCount.style.background = 'rgba(244, 67, 54, 0.9)'; // Red for empty
                } else if (deckCount <= 5) {
                    playerDeckCount.style.background = 'rgba(255, 152, 0, 0.9)'; // Orange for low
                } else {
                    playerDeckCount.style.background = 'rgba(0, 0, 0, 0.8)'; // Default black
                }
            }
            
            if (opponentDeckCount && gameState.opponentState) {
                const deckCount = gameState.opponentState.deckCount || (gameState.opponentState.deck ? gameState.opponentState.deck.length : 0);
                opponentDeckCount.textContent = deckCount;
                
                // Change color based on deck count
                if (deckCount === 0) {
                    opponentDeckCount.style.background = 'rgba(244, 67, 54, 0.9)'; // Red for empty
                } else if (deckCount <= 5) {
                    opponentDeckCount.style.background = 'rgba(255, 152, 0, 0.9)'; // Orange for low
                } else {
                    opponentDeckCount.style.background = 'rgba(0, 0, 0, 0.8)'; // Default black
                }
            }
        }
        
        // Show game message
        function showGameMessage(message, duration = 3000) {
            gameMessages.textContent = message;
            gameMessages.style.display = 'block';
            setTimeout(() => {
                gameMessages.style.display = 'none';
            }, duration);
        }
        
        // Make showGameMessage globally available
        window.showGameMessage = showGameMessage;
        
        // Update turn display
        function updateTurnDisplay(gameInfo) {
            currentTurn = gameInfo.turn;
            isMyTurn = gameInfo.isYourTurn;
            
            turnNumberSpan.textContent = currentTurn;
            
            if (isMyTurn) {
                turnStatusDiv.textContent = 'YOUR TURN';
                turnStatusDiv.className = 'your-turn';
                showGameMessage('It\'s your turn! You can move cards and play actions.', 2000);
            } else {
                turnStatusDiv.textContent = 'OPPONENT\'S TURN';
                turnStatusDiv.className = 'opponent-turn';
            }
        }
        
        // Add End Turn button functionality
        function addEndTurnButton() {
            if (document.getElementById('end-turn-btn')) return; // Already exists
            
            const endTurnBtn = document.createElement('button');
            endTurnBtn.id = 'end-turn-btn';
            endTurnBtn.textContent = 'End Turn';
            endTurnBtn.style.cssText = `
                position: fixed;
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                z-index: 1000;
                display: none;
            `;
            
            endTurnBtn.addEventListener('click', () => {
                if (isMyTurn) {
                    wsClient.sendEndTurn();
                    endTurnBtn.style.display = 'none';
                    showGameMessage('Turn ended. Waiting for opponent...', 2000);
                }
            });
            
            document.body.appendChild(endTurnBtn);
            return endTurnBtn;
        }

        // Add Attack and Ability buttons for active Pokemon
        function addActionButtons() {
            // Remove existing action buttons
            const existingButtons = document.querySelectorAll('.action-btn, .help-message');
            existingButtons.forEach(btn => btn.remove());

            if (!isMyTurn) return; // Only show buttons on player's turn

            const activePokemon = document.getElementById('ActivePokemon');
            if (!activePokemon || !activePokemon.cardData) {
                // Show help message if no active Pokemon
                showHelpMessage("Place a Pokémon in your Active slot to see attack options!");
                return;
            }

            const pokemonData = activePokemon.cardData;
            let buttonIndex = 0;

            // Show help message about attacks
            if (pokemonData.attacks && pokemonData.attacks.length > 0) {
                showHelpMessage("Click attack buttons to battle! Energy requirements are shown.");
            }

            // Add attack buttons
            if (pokemonData.attacks && pokemonData.attacks.length > 0) {
                pokemonData.attacks.forEach((attack, index) => {
                    // Create energy cost display
                    const energyCostText = attack.energyCost && attack.energyCost.length > 0 
                        ? ` (${attack.energyCost.length} energy)` 
                        : '';
                    
                    const canUseAttack = checkCanUseAttack(pokemonData, attack);
                    const buttonText = `⚔️ ${attack.name}${energyCostText}`;
                    const tooltipText = `${attack.description}\nEnergy Cost: ${attack.energyCost ? attack.energyCost.join(', ') : 'None'}${canUseAttack ? '' : '\n❌ Not enough energy!'}`;
                    
                    const attackBtn = createActionButton(
                        buttonText,
                        tooltipText,
                        buttonIndex++,
                        () => useAttack(attack.name),
                        'attack'
                    );
                    
                    // Disable button if can't use attack
                    if (!canUseAttack) {
                        attackBtn.style.opacity = '0.5';
                        attackBtn.style.cursor = 'not-allowed';
                        attackBtn.title += '\n❌ Not enough energy!';
                    }
                    
                    document.body.appendChild(attackBtn);
                });
            }

            // Add ability buttons  
            if (pokemonData.abilities && pokemonData.abilities.length > 0) {
                console.log('DEBUG: Action buttons abilities data:', pokemonData.abilities);
                pokemonData.abilities.forEach((ability, index) => {
                    console.log(`DEBUG: Processing ability ${index} for action button:`, ability);
                    const abilityBtn = createActionButton(
                        `✨ ${ability.name}`,
                        `${ability.name}: ${ability.description}`,
                        buttonIndex++,
                        () => useAbility(ability.name),
                        'ability'
                    );
                    document.body.appendChild(abilityBtn);
                });
            }
        }

        function createActionButton(text, title, index, onClick, type = 'attack') {
            const btn = document.createElement('button');
            btn.className = 'action-btn';
            btn.innerHTML = text; // Use innerHTML to support energy icons
            btn.title = title;
            
            const bgColor = type === 'attack' ? '#f44336' : '#4CAF50'; // Red for attacks, green for abilities
            
            btn.style.cssText = `
                position: fixed;
                bottom: ${10 + (index * 50)}px;
                left: 10px;
                padding: 8px 12px;
                background: ${bgColor};
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 11px;
                z-index: 1000;
                min-width: 150px;
                max-width: 200px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                transition: transform 0.1s;
            `;
            
            btn.addEventListener('mousedown', () => {
                btn.style.transform = 'scale(0.95)';
            });
            
            btn.addEventListener('mouseup', () => {
                btn.style.transform = 'scale(1)';
            });
            
            btn.addEventListener('click', onClick);
            return btn;
        }

        // Use attack function
        function useAttack(attackName) {
            console.log(`Attempting to use attack: ${attackName}`);
            
            // Check WebSocket connection
            if (!wsClient.connected) {
                showGameMessage('❌ Not connected to server! Please join a game first.', 3000);
                return;
            }
            
            // Check if game is in progress
            if (!wsClient.gameId) {
                showGameMessage('❌ Not in a game! Please join a game first.', 3000);
                return;
            }
            
            // Check if it's the player's turn
            if (!isMyTurn) {
                showGameMessage('❌ Not your turn!', 2000);
                return;
            }
            
            console.log(`Sending attack: ${attackName}`);
            const success = wsClient.send('use_attack', { attackName: attackName });
            
            if (success) {
                showGameMessage(`⚔️ Using ${attackName}...`, 2000);
            } else {
                showGameMessage('❌ Failed to send attack command!', 3000);
            }
        }

        // Use ability function  
        function useAbility(abilityName) {
            console.log(`Attempting to use ability: ${abilityName}`);
            
            // Check WebSocket connection
            if (!wsClient.connected) {
                showGameMessage('❌ Not connected to server! Please join a game first.', 3000);
                return;
            }
            
            // Check if game is in progress
            if (!wsClient.gameId) {
                showGameMessage('❌ Not in a game! Please join a game first.', 3000);
                return;
            }
            
            // Check if it's the player's turn
            if (!isMyTurn) {
                showGameMessage('❌ Not your turn!', 2000);
                return;
            }
            
            console.log(`Sending ability: ${abilityName}`);
            const success = wsClient.send('use_ability', { abilityName: abilityName });
            
            if (success) {
                showGameMessage(`✨ Using ${abilityName}...`, 2000);
            } else {
                showGameMessage('❌ Failed to send ability command!', 3000);
            }
        }

        // Check if Pokemon has enough energy for an attack
        function checkCanUseAttack(pokemonData, attack) {
            if (!attack.energyCost || attack.energyCost.length === 0) {
                return true; // No energy required
            }

            const attachedEnergy = pokemonData.attachedEnergy || [];
            const energyCount = {};

            // Count attached energy by type
            attachedEnergy.forEach(energy => {
                const type = energy.energyType || energy.type;
                energyCount[type] = (energyCount[type] || 0) + 1;
            });

            // Count required energy by type
            const requiredEnergy = {};
            attack.energyCost.forEach(type => {
                requiredEnergy[type] = (requiredEnergy[type] || 0) + 1;
            });

            // Create a copy of energyCount to track what's been used
            const availableEnergy = { ...energyCount };

            // First, satisfy all non-colorless energy requirements
            for (const [type, required] of Object.entries(requiredEnergy)) {
                if (type !== 'colorless') {
                    if ((availableEnergy[type] || 0) < required) {
                        return false; // Not enough specific energy type
                    }
                    // Use up the specific energy type
                    availableEnergy[type] -= required;
                }
            }

            // Now handle colorless energy requirements - can use any remaining energy
            const colorlessRequired = requiredEnergy['colorless'] || 0;
            if (colorlessRequired > 0) {
                const totalRemainingEnergy = Object.values(availableEnergy).reduce((sum, count) => sum + count, 0);
                if (totalRemainingEnergy < colorlessRequired) {
                    return false; // Not enough energy for colorless cost
                }
            }

            return true;
        }

        // Show help message
        function showHelpMessage(message) {
            const helpDiv = document.createElement('div');
            helpDiv.className = 'help-message';
            helpDiv.textContent = message;
            helpDiv.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                padding: 8px 12px;
                background: rgba(33, 150, 243, 0.9);
                color: white;
                border-radius: 6px;
                font-size: 12px;
                z-index: 999;
                max-width: 250px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(helpDiv);
        }
        
        // Set up WebSocket event listeners
        wsClient.on('waiting_for_opponent', (data) => {
            updateConnectionStatus('waiting', 'Waiting for opponent...');
            showGameMessage('Waiting for another player to join...', 5000);
        });
        
        wsClient.on('game_found', (data) => {
            updateConnectionStatus('connected', 'Connected');
            playerNumberSpan.textContent = data.playerNumber;
            opponentNameSpan.textContent = data.opponent;
            showGameMessage(`Game found! You are Player ${data.playerNumber}. Opponent: ${data.opponent}`);
            
            // Set up the game
            setupGame(data.playerNumber);
            
            // Send ready signal
            setTimeout(() => {
                wsClient.sendPlayerReady();
            }, 1000);
        });
        
        wsClient.on('game_start', (data) => {
            showGameMessage('Game started! You can now move your cards.');
            // The game.start() method already initializes drag and drop with game reference
            // and sends initial state for synchronization
            
            // Initialize deck count displays when game starts
            initializeDeckCounts();
        });
        
        // Handle game state updates from server
        wsClient.on('game_state_update', (data) => {
            console.log('Received game state update:', data);
            // Data contains { gameState: {...} }, so we need to extract gameState
            const gameState = data.gameState;
            if (window.currentGame && gameState) {
                window.currentGame.updateFromServerState(gameState);
                
                // Update turn display - turn info is directly in gameState
                updateTurnDisplay({
                    turn: gameState.turn,
                    isYourTurn: gameState.isYourTurn
                });
                
                // Update deck counts
                updateDeckCounts(gameState);
                
                // Show/hide end turn button
                const endTurnBtn = document.getElementById('end-turn-btn') || addEndTurnButton();
                if (gameState.isYourTurn) {
                    endTurnBtn.style.display = 'block';
                } else {
                    endTurnBtn.style.display = 'none';
                }

                // Update action buttons based on active Pokemon
                addActionButtons();
            } else {
                console.error('No currentGame found or no gameState in data:', data);
            }
        });

        // Handle turn changes
        wsClient.on('turn_changed', (data) => {
            console.log('Turn changed:', data);
            const newIsMyTurn = data.currentPlayer === playerNumber;
            
            // Update global turn state for guiHookUtils.isMyTurn() method
            window.isMyTurn = newIsMyTurn;
            console.log('DEBUG: Set window.isMyTurn to:', window.isMyTurn);
            
            updateTurnDisplay({
                turn: data.turn,
                isYourTurn: newIsMyTurn
            });
            
            // Update deck counts if gameState is provided
            if (data.gameState) {
                updateDeckCounts(data.gameState);
            }
            
            // Update drag controls when turn changes
            if (window.currentGame && window.currentGame.guiHook) {
                const turnReason = newIsMyTurn ? 
                    'Your turn - you can move cards' : 
                    'Opponent\'s turn - wait for your turn';
                window.currentGame.guiHook.setDragEnabled(newIsMyTurn, turnReason);
                
                // Force reset energy flag when it becomes my turn
                if (newIsMyTurn) {
                    console.log('DEBUG: My turn detected - forcing energy flag reset');
                    window.currentGame.guiHook.onTurnStart();
                }
            }
            
            showGameMessage(data.message, 3000);
        });

        // Handle action errors
        wsClient.on('action_error', (data) => {
            console.error('Action error from server:', data);
            showGameMessage(`Action failed: ${data.message}`, 5000);
        });

        wsClient.on('move_error', (data) => {
            console.error('Move error from server:', data);
            showGameMessage(`Move error: ${data.message}`, 5000);
            
            // Rollback the move on client side
            if (window.currentGame && window.currentGame.guiHook && window.currentGame.guiHook.rollbackLastMove) {
                window.currentGame.guiHook.rollbackLastMove();
            }
        });
        
        wsClient.on('move_success', (data) => {
            console.log('Move confirmed by server:', data);
            // Clear rollback data since move was successful
            if (guiHook) {
                guiHook.lastMove = null;
            }
        });

        wsClient.on('attack_used', (data) => {
            console.log('Attack successful:', data);
            showGameMessage(`${data.attackName} used! ${data.result.message || ''}`, 3000);
        });

        wsClient.on('ability_used', (data) => {
            console.log('Ability successful:', data);
            showGameMessage(`${data.abilityName} activated! ${data.result.message || ''}`, 3000);
        });

        wsClient.on('action_error', (data) => {
            console.log('Action error:', data);
            showGameMessage(`❌ ${data.message}`, 3000);
        });
        
        wsClient.on('opponent_disconnected', (data) => {
            updateConnectionStatus('disconnected', 'Opponent disconnected');
            showGameMessage(data.message, 10000);
        });
        
        wsClient.on('connection_lost', (data) => {
            updateConnectionStatus('disconnected', 'Connection lost');
            showGameMessage('Lost connection to server. Please refresh to reconnect.', 10000);
        });
        
        // Join game button handler
        joinButton.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            currentUsername = username;
            currentUsernameSpan.textContent = username;
            
            try {
                updateConnectionStatus('connecting', 'Connecting...');
                // Let WebSocketClient auto-detect the correct URL for Codespaces
                await wsClient.connect();
                wsClient.joinGame(username);
                usernameModal.style.display = 'none';
            } catch (error) {
                console.error('Failed to connect:', error);
                updateConnectionStatus('disconnected', 'Connection failed');
                alert('Failed to connect to server. Please try again.');
            }
        });
        
        // Enter key handler for username input
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinButton.click();
            }
        });
        
        // Set up game based on player number
        function setupGame(pNum) {
            playerNumber = pNum; // Store globally for turn management
            
            // Create minimal client objects (server manages all game state)
            player1 = new Client(currentUsername);
            player2 = new Client('Opponent');

            // Create the game with centralized state management
            game = new Game(player1, player2, guiHook);
            
            // Link the WebSocket client to the game for action handling
            game.wsClient = wsClient;
            
            // Store game globally for WebSocket handlers
            window.currentGame = game;

            try {
                // Server will send initial game state including decks and hands
                game.start();
                
                // Initialize deck count displays
                initializeDeckCounts();

                // Add debug helper to window for troubleshooting
                window.debugEnergy = function() {
                    console.log('=== ENERGY DEBUG INFO ===');
                    const handCards = document.querySelectorAll('#PlayerHand .card');
                    console.log('Hand cards found:', handCards.length);
                    
                    handCards.forEach((card, i) => {
                        const cardData = card.cardData || card._cardData;
                        console.log(`Card ${i}:`, cardData);
                        if (cardData && cardData.type === 'energy') {
                            console.log(`  -> Energy card detected: ${cardData.cardName}`);
                        }
                    });
                    
                    const pokemonSlots = document.querySelectorAll('.card.player:not(.empty):not(.hand .card)');
                    console.log('Pokemon slots with cards:', pokemonSlots.length);
                    pokemonSlots.forEach((slot, i) => {
                        console.log(`Pokemon slot ${i}:`, slot);
                    });
                };
                
                console.log('Game setup complete. Type "debugEnergy()" in console to debug energy attachment issues.');

            } catch (error) {
                console.error('Error setting up game:', error);
            }
        }
    </script>
</body>
<script src="/Lib/GUI.Demo/BoardDynamicSizing.js"></script>

</html>