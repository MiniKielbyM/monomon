<!DOCTYPE html>
<html>

<head>
    <title>Pokemon TCG - Multiplayer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="Lib/GUI.Demo/BoardLayout.css">
</head>

<body>

    <!-- Username Modal -->
    <div id="username-modal">
        <div id="username-form">
            <h2>Join Pokemon TCG Game</h2>
            <input type="text" id="username-input" placeholder="Enter your username " maxlength="20">
            <br>
            <button id="join-button">Join Game</button>
        </div>
        
    </div>

    <!-- Deck Builder Modal -->
    <div id="deck-builder-modal">
        <div>
            <h2>Build Your Deck</h2>
            <div id="deck-opponent">Opponent: <span
                    id="deck-opponent-name">Waiting for opponent...</span></div>
            <div id="deck-builder-list"></div>
            <div>Cards in deck: <span id="deck-card-count">0</span>/60</div>
            <button id="submit-deck-button" disabled>Submit Deck</button>
        </div>
    </div>

    <!-- Coin Flip Modal -->
    <div id="coin-flip-modal">
        <div id="coin-flip-container">
            <div id="coin-flip-title">Coin Flip</div>
            <div id="coin">
                <div class="coin-side coin-heads">HEADS</div>
                <div class="coin-side coin-tails">TAILS</div>
            </div>
            <div id="coin-result"></div>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" class="status-disconnected">
        Disconnected
        <span class="loader"></span>
    </div>

    <!-- Game Messages -->
    <div id="game-messages"></div>

    <!-- Player Info -->
    <div id="player-info">
        <div>Player: <span id="current-username">-</span></div>
        <div>Player Number: <span id="player-number">-</span></div>
        <div>Opponent: <span id="opponent-name">-</span></div>
        <div>Turn: <span id="turn-number">-</span></div>
        <div id="turn-status">Waiting for game to start...</div>
    </div>

    <div id="aspect-box">
        <div id="sixteenbynine">

            <div id="opponent-zone">
                <div class="bench">
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                    <div class="card benched opp empty"></div>
                </div>
                <div class="card active opp empty"></div>
                <div class="card lost-zone opp empty"></div>
                <div class="card discard opp empty"></div>
                <div class="deck opp"></div>
                <div class="prize-zone one">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
                <div class="prize-zone two">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
                <div class="prize-zone three">
                    <div class="card opp prize faceDown"></div>
                    <div class="card opp prize faceDown"></div>
                </div>
            </div>
            <div id="player-zone">
                <div id="ActivePokemon" class="card active player empty"></div>
                <div class="bench">
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                    <div class="card player benched empty"></div>
                </div>
                <div class="hand-outer">
                    <div class="hand-inner">
                        <div id="PlayerHand" class="hand">
                        </div>
                    </div>
                </div>
                <div class="prize-zone one">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="prize-zone two">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="prize-zone three">
                    <div class="card player prize faceDown"></div>
                    <div class="card player prize faceDown"></div>
                </div>
                <div class="deck player"></div>
                <div class="card discard player empty"></div>
                <div class="card lost-zone player empty"></div>
            </div>

        </div>
    </div>

    <script type="module">
        import Client from './Lib/client.js';
        import Game from './Lib/game.js';
        // Deck import removed - server manages all deck state
        import GUIHookUtils from './Lib/guiHookUtils.js';
        import WebSocketClient from './Lib/webSocketClient.js';
        import enums from './Lib/enums.js';
        // Card imports removed - server creates all card instances

        const { PokemonType, CardModifiers } = enums;
        // Card destructuring removed - server provides all card data

        // Initialize WebSocket client and GUI
        const wsClient = new WebSocketClient();
        const guiHook = new GUIHookUtils(document.body, wsClient);

        // Make wsClient available globally for attack functions
        window.wsClient = wsClient;

        // UI Elements
        const usernameModal = document.getElementById('username-modal');
        const usernameInput = document.getElementById('username-input');
        const joinButton = document.getElementById('join-button');
        const connectionStatus = document.getElementById('connection-status');
        const gameMessages = document.getElementById('game-messages');
        const currentUsernameSpan = document.getElementById('current-username');
        const playerNumberSpan = document.getElementById('player-number');
        const opponentNameSpan = document.getElementById('opponent-name');
        const turnNumberSpan = document.getElementById('turn-number');
        const turnStatusDiv = document.getElementById('turn-status');

        let currentUsername = '';
        let playerNumber = 0;
        let currentTurn = 0;
        let isMyTurn = false;
        let player1, player2, game;
        let deckSubmitted = false;
        let currentDeck = [];
        // --- Deck builder logic ---
        const deckBuilderModal = document.getElementById('deck-builder-modal');
        const deckBuilderList = document.getElementById('deck-builder-list');
        const deckCardCount = document.getElementById('deck-card-count');
        const submitDeckButton = document.getElementById('submit-deck-button');


        // Fetch card data from cardData.js (ESM import via dynamic import)
        let cardPool = [];
        async function loadCardPool() {
            // Try to import cardData.js as an ES module
            try {
                const cardData = await import('./Server/cardData.js');
                // Merge all cards into one pool
                cardPool = [];
                if (Array.isArray(cardData.pokemonCards)) cardPool = cardPool.concat(cardData.pokemonCards);
                if (Array.isArray(cardData.energyCards)) cardPool = cardPool.concat(cardData.energyCards);
                // Normalize for builder
                cardPool = cardPool.map(card => ({
                    cardName: card.name || card.cardName,
                    type: card.type,
                    imgUrl: card.imgUrl,
                    ...card
                }));
                // Sort alphabetically by cardName for predictable builder ordering
                cardPool.sort((a, b) => (a.cardName || '').toLowerCase().localeCompare((b.cardName || '').toLowerCase()));
            } catch (e) {
                // Fallback: minimal pool
                cardPool = [
                    { cardName: 'Pikachu', type: 'pokemon', imgUrl: 'https://images.pokemontcg.io/base1/58_hires.png' },
                    { cardName: 'Blastoise', type: 'pokemon', imgUrl: 'https://images.pokemontcg.io/base1/2_hires.png' },
                    { cardName: 'Fire Energy', type: 'energy', imgUrl: 'https://images.pokemontcg.io/base1/98_hires.png' },
                    { cardName: 'Water Energy', type: 'energy', imgUrl: 'https://images.pokemontcg.io/base1/102_hires.png' },
                    { cardName: 'Bill', type: 'trainer', imgUrl: 'https://images.pokemontcg.io/base1/91_hires.png' },
                ];
                cardPool.sort((a, b) => (a.cardName || '').toLowerCase().localeCompare((b.cardName || '').toLowerCase()));
            }
        }

        async function openDeckBuilder(opponentName) {
            currentDeck = [];
            await loadCardPool();
            updateDeckBuilder();
            // Show opponent name if provided
            const opponentSpan = document.getElementById('deck-opponent-name');
            if (opponentSpan) opponentSpan.textContent = opponentName || 'Waiting for opponent...';
            deckBuilderModal.style.display = 'flex';
        }

        function updateDeckBuilder() {
            deckBuilderList.innerHTML = '';
            cardPool.forEach(card => {
                const count = currentDeck.filter(c => c.cardName === card.cardName).length;
                const cardDiv = document.createElement('div');
                cardDiv.style.display = 'flex';
                cardDiv.style.alignItems = 'center';
                cardDiv.style.marginBottom = '4px';
                cardDiv.innerHTML = `<img src="${card.imgUrl}" style="width:40px; height:56px; object-fit:cover; margin-right:8px;"> <span>${card.cardName}</span> <span style="margin-left:auto;">x${count}</span>`;
                const addBtn = document.createElement('button');
                addBtn.textContent = '+';
                addBtn.style.marginLeft = '8px';
                addBtn.onclick = () => {
                    if (currentDeck.length < 60) {
                        currentDeck.push(card);
                        updateDeckBuilder();
                    }
                };
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '-';
                removeBtn.onclick = () => {
                    const idx = currentDeck.findIndex(c => c.cardName === card.cardName);
                    if (idx !== -1) {
                        currentDeck.splice(idx, 1);
                        updateDeckBuilder();
                    }
                };
                cardDiv.appendChild(addBtn);
                cardDiv.appendChild(removeBtn);
                deckBuilderList.appendChild(cardDiv);
            });
            deckCardCount.textContent = currentDeck.length;
            submitDeckButton.disabled = currentDeck.length !== 60;
        }

        submitDeckButton.onclick = () => {
            wsClient.send('submit_deck', { deck: currentDeck });
        };
        // Listen for server deck messages
        wsClient.on('deck_required', (data) => {
            // data may include opponent name when available
            const opponent = data && data.opponent ? data.opponent : null;
            openDeckBuilder(opponent);
        });
        wsClient.on('deck_received', () => {
            deckSubmitted = true;
            deckBuilderModal.style.display = 'none';
            showGameMessage('Deck submitted! Waiting for opponent...', 3000);
        });
        wsClient.on('deck_error', (data) => {
            showGameMessage('Deck error: ' + (data.message || 'Unknown error'), 4000);
        });

        // Update connection status
        function updateConnectionStatus(status, message) {
            connectionStatus.className = `status-${status}`;
            connectionStatus.innerHTML = message + ' <span class="loader"></span>';
        }

        // Initialize deck count displays
        function initializeDeckCounts() {
            const playerDeck = document.querySelector('.deck.player');
            const opponentDeck = document.querySelector('.deck.opp');

            if (playerDeck && !playerDeck.querySelector('.deck-count')) {
                const playerDeckCount = document.createElement('div');
                playerDeckCount.className = 'deck-count';
                playerDeckCount.id = 'player-deck-count';
                playerDeckCount.textContent = '60';
                playerDeck.appendChild(playerDeckCount);
            }

            if (opponentDeck && !opponentDeck.querySelector('.deck-count')) {
                const opponentDeckCount = document.createElement('div');
                opponentDeckCount.className = 'deck-count';
                opponentDeckCount.id = 'opponent-deck-count';
                opponentDeckCount.textContent = '60';
                opponentDeck.appendChild(opponentDeckCount);
            }
        }

        // Update deck count displays
        function updateDeckCounts(gameState) {
            if (!gameState) return;

            const playerDeckCount = document.getElementById('player-deck-count');
            const opponentDeckCount = document.getElementById('opponent-deck-count');

            if (playerDeckCount && gameState.yourState) {
                const deckCount = gameState.yourState.deckCount || (gameState.yourState.deck ? gameState.yourState.deck.length : 0);
                playerDeckCount.textContent = deckCount;

                // Change color based on deck count
                if (deckCount === 0) {
                    playerDeckCount.style.background = 'rgba(244, 67, 54, 0.9)'; // Red for empty
                } else if (deckCount <= 5) {
                    playerDeckCount.style.background = 'rgba(255, 152, 0, 0.9)'; // Orange for low
                } else {
                    playerDeckCount.style.background = 'rgba(0, 0, 0, 0.8)'; // Default black
                }
            }

            if (opponentDeckCount && gameState.opponentState) {
                const deckCount = gameState.opponentState.deckCount || (gameState.opponentState.deck ? gameState.opponentState.deck.length : 0);
                opponentDeckCount.textContent = deckCount;

                // Change color based on deck count
                if (deckCount === 0) {
                    opponentDeckCount.style.background = 'rgba(244, 67, 54, 0.9)'; // Red for empty
                } else if (deckCount <= 5) {
                    opponentDeckCount.style.background = 'rgba(255, 152, 0, 0.9)'; // Orange for low
                } else {
                    opponentDeckCount.style.background = 'rgba(0, 0, 0, 0.8)'; // Default black
                }
            }
        }

        // Show game message
        function showGameMessage(message, duration = 3000) {
            gameMessages.textContent = message;
            gameMessages.style.display = 'block';
            setTimeout(() => {
                gameMessages.style.display = 'none';
            }, duration);
        }

        function updatePrizeCards(gameState) {
            if (!gameState) return;

            // Update player prize cards
            if (gameState.yourState && gameState.yourState.prizeCards) {
                const playerPrizeCards = document.querySelectorAll('.card.player.prize');
                const prizeCards = gameState.yourState.prizeCards;
                const remainingPrizes = prizeCards.filter(card => card !== null).length;

                // Remove excess card elements if we have more DOM elements than remaining prizes
                if (playerPrizeCards.length > remainingPrizes) {
                    const cardsToRemove = playerPrizeCards.length - remainingPrizes;
                    for (let i = 0; i < cardsToRemove; i++) {
                        const cardToRemove = playerPrizeCards[playerPrizeCards.length - 1 - i];
                        if (cardToRemove) {
                            cardToRemove.remove();
                        }
                    }
                }
            }

            // Update opponent prize cards
            if (gameState.opponentState && gameState.opponentState.prizeCards) {
                const opponentPrizeCards = document.querySelectorAll('.card.opp.prize');
                const prizeCards = gameState.opponentState.prizeCards;
                const remainingPrizes = prizeCards.filter(card => card !== null).length;

                // Remove excess card elements if we have more DOM elements than remaining prizes
                if (opponentPrizeCards.length > remainingPrizes) {
                    const cardsToRemove = opponentPrizeCards.length - remainingPrizes;
                    for (let i = 0; i < cardsToRemove; i++) {
                        const cardToRemove = opponentPrizeCards[opponentPrizeCards.length - 1 - i];
                        if (cardToRemove) {
                            cardToRemove.remove();
                        }
                    }
                }
            }
        }

        function updateDiscardPiles(gameState) {
            if (!gameState) return;

            // Update player's discard pile
            if (gameState.yourState && gameState.yourState.discardPile) {
                const playerDiscardElement = document.querySelector('.card.discard.player');
                if (playerDiscardElement && gameState.yourState.discardPile.length > 0) {
                    const topCard = gameState.yourState.discardPile[gameState.yourState.discardPile.length - 1];
                    if (topCard) {
                        playerDiscardElement.classList.remove('empty');
                        // Use the card's imgUrl property instead of constructing the path
                        const imageUrl = topCard.imgUrl || topCard.cardImageUrl || `../../Cards/Base/Base Set/${topCard.cardName.replace(/\s+/g, '_')}.png`;
                        playerDiscardElement.style.backgroundImage = `url('${imageUrl}')`;
                        playerDiscardElement.setAttribute('data-card-name', topCard.cardName);
                        playerDiscardElement.setAttribute('data-card-count', gameState.yourState.discardPile.length);
                    }
                } else if (playerDiscardElement) {
                    playerDiscardElement.classList.add('empty');
                    playerDiscardElement.style.backgroundImage = '';
                    playerDiscardElement.removeAttribute('data-card-name');
                    playerDiscardElement.removeAttribute('data-card-count');
                }
            }

            // Update opponent's discard pile
            if (gameState.opponentState && gameState.opponentState.discardPile) {
                const oppDiscardElement = document.querySelector('.card.discard.opp');
                if (oppDiscardElement && gameState.opponentState.discardPile.length > 0) {
                    const topCard = gameState.opponentState.discardPile[gameState.opponentState.discardPile.length - 1];
                    if (topCard) {
                        oppDiscardElement.classList.remove('empty');
                        // Use the card's imgUrl property instead of constructing the path
                        const imageUrl = topCard.imgUrl || topCard.cardImageUrl || `../../Cards/Base/Base Set/${topCard.cardName.replace(/\s+/g, '_')}.png`;
                        oppDiscardElement.style.backgroundImage = `url('${imageUrl}')`;
                        oppDiscardElement.setAttribute('data-card-name', topCard.cardName);
                        oppDiscardElement.setAttribute('data-card-count', gameState.opponentState.discardPile.length);
                    }
                } else if (oppDiscardElement) {
                    oppDiscardElement.classList.add('empty');
                    oppDiscardElement.style.backgroundImage = '';
                    oppDiscardElement.removeAttribute('data-card-name');
                    oppDiscardElement.removeAttribute('data-card-count');
                }
            }
        }

        // Make showGameMessage globally available
        window.showGameMessage = showGameMessage;

        function showCoinFlipToAllClients(result, playerName) {
            const modal = document.getElementById('coin-flip-modal');
            const coin = document.getElementById('coin');
            const coinResult = document.getElementById('coin-result');
            const coinTitle = document.getElementById('coin-flip-title');

            if (!modal) {
                console.warn('Coin flip modal not found');
                return;
            }

            // Reset coin state
            coin.className = '';
            coinResult.textContent = '';
            coinResult.classList.remove('result-visible');

            // Set title to show which player flipped
            coinTitle.textContent = playerName ? `${playerName} flips a coin` : 'Coin Flip';

            // Show modal
            modal.style.display = 'flex';

            // Start spinning animation
            coin.classList.add('coin-spinning');

            // After spinning, show result
            setTimeout(() => {
                coin.classList.remove('coin-spinning');
                coin.classList.add(result ? 'coin-result-heads' : 'coin-result-tails');
                coinResult.textContent = result ? 'HEADS!' : 'TAILS!';
                coinResult.classList.add('result-visible');

                // Hide modal after showing result
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 1500);
            }, 2000); // Match animation duration
        }

        // Make showCoinFlipToAllClients globally available
        window.showCoinFlipToAllClients = showCoinFlipToAllClients;

        // Update turn display
        function updateTurnDisplay(gameInfo) {
            currentTurn = gameInfo.turn;
            isMyTurn = gameInfo.isYourTurn;

            turnNumberSpan.textContent = currentTurn;

            if (isMyTurn) {
                turnStatusDiv.textContent = 'YOUR TURN';
                turnStatusDiv.className = 'your-turn';
                showGameMessage('It\'s your turn! You can move cards and play actions.', 2000);
            } else {
                turnStatusDiv.textContent = 'OPPONENT\'S TURN';
                turnStatusDiv.className = 'opponent-turn';
            }
        }

        // Add End Turn button functionality
        function addEndTurnButton() {
            if (document.getElementById('end-turn-btn')) return; // Already exists

            const endTurnBtn = document.createElement('button');
            endTurnBtn.id = 'end-turn-btn';
            endTurnBtn.textContent = 'End Turn';
            endTurnBtn.style.cssText = `
                position: fixed;
                bottom: 10px;
                right: 10px;
                padding: 10px 20px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                z-index: 1000;
                display: none;
            `;

            endTurnBtn.addEventListener('click', () => {
                if (isMyTurn) {
                    wsClient.sendEndTurn();
                    endTurnBtn.style.display = 'none';
                    showGameMessage('Turn ended. Waiting for opponent...', 2000);
                }
            });

            document.body.appendChild(endTurnBtn);
            return endTurnBtn;
        }

        // Add Attack and Ability buttons for active Pokemon
        function addActionButtons() {
            // Remove existing action buttons
            const existingButtons = document.querySelectorAll('.action-btn, .help-message');
            existingButtons.forEach(btn => btn.remove());

            if (!isMyTurn) return; // Only show buttons on player's turn

            const activePokemon = document.getElementById('ActivePokemon');
            if (!activePokemon || !activePokemon.cardData) {
                // Show help message if no active Pokemon
                showHelpMessage("Place a Pokémon in your Active slot to see attack options!");
                return;
            }

            const pokemonData = activePokemon.cardData;
            let buttonIndex = 0;

            // Show help message about attacks
            if (pokemonData.attacks && pokemonData.attacks.length > 0) {
                showHelpMessage("Click attack buttons to battle! Energy requirements are shown.");
            }

            // Add attack buttons
            if (pokemonData.attacks && pokemonData.attacks.length > 0) {
                pokemonData.attacks.forEach((attack, index) => {
                    // Create energy cost display
                    const energyCostText = attack.energyCost && attack.energyCost.length > 0
                        ? ` (${attack.energyCost.length} energy)`
                        : '';

                    const canUseAttack = checkCanUseAttack(pokemonData, attack);
                    const buttonText = `⚔️ ${attack.name}${energyCostText}`;
                    const tooltipText = `${attack.description}\nEnergy Cost: ${attack.energyCost ? attack.energyCost.join(', ') : 'None'}${canUseAttack ? '' : '\n❌ Not enough energy!'}`;

                    const attackBtn = createActionButton(
                        buttonText,
                        tooltipText,
                        buttonIndex++,
                        () => useAttack(attack.name),
                        'attack'
                    );

                    // Disable button if can't use attack
                    if (!canUseAttack) {
                        attackBtn.style.opacity = '0.5';
                        attackBtn.style.cursor = 'not-allowed';
                        attackBtn.title += '\n❌ Not enough energy!';
                    }

                    document.body.appendChild(attackBtn);
                });
            }

            // Add ability buttons  
            if (pokemonData.abilities && pokemonData.abilities.length > 0) {
                console.log('DEBUG: Action buttons abilities data:', pokemonData.abilities);
                pokemonData.abilities.forEach((ability, index) => {
                    console.log(`DEBUG: Processing ability ${index} for action button:`, ability);
                    const abilityBtn = createActionButton(
                        `✨ ${ability.name}`,
                        `${ability.name}: ${ability.description}`,
                        buttonIndex++,
                        () => useAbility(ability.name),
                        'ability'
                    );
                    document.body.appendChild(abilityBtn);
                });
            }

            // Add evolution buttons
            if (window.currentGame && window.currentGame.serverGameState && window.currentGame.serverGameState.yourState) {
                const hand = window.currentGame.serverGameState.yourState.hand || [];
                const evolutionCards = hand.filter(card => card.evolvesFrom);

                if (evolutionCards.length > 0) {
                    evolutionCards.forEach((evolutionCard, index) => {
                        // Check if we have valid targets for this evolution
                        const canEvolve = checkCanEvolve(evolutionCard);

                        const evolutionBtn = createActionButton(
                            `🔄 Evolve to ${evolutionCard.cardName}`,
                            `Evolve from ${evolutionCard.evolvesFrom} to ${evolutionCard.cardName}${canEvolve ? '' : '\n❌ No valid targets to evolve!'}`,
                            buttonIndex++,
                            () => startEvolution(evolutionCard),
                            'evolution'
                        );

                        // Disable button if can't evolve
                        if (!canEvolve) {
                            evolutionBtn.style.opacity = '0.5';
                            evolutionBtn.style.cursor = 'not-allowed';
                        }

                        document.body.appendChild(evolutionBtn);
                    });
                }
            }
        }

        function createActionButton(text, title, index, onClick, type = 'attack') {
            const btn = document.createElement('button');
            btn.className = 'action-btn';
            btn.innerHTML = text; // Use innerHTML to support energy icons
            btn.title = title;

            const bgColor = type === 'attack' ? '#f44336' : type === 'ability' ? '#4CAF50' : '#FF9800'; // Red for attacks, green for abilities, orange for evolution

            btn.style.cssText = `
                position: fixed;
                bottom: ${10 + (index * 50)}px;
                left: 10px;
                padding: 8px 12px;
                background: ${bgColor};
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 11px;
                z-index: 1000;
                min-width: 150px;
                max-width: 200px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                transition: transform 0.1s;
            `;

            btn.addEventListener('mousedown', () => {
                btn.style.transform = 'scale(0.95)';
            });

            btn.addEventListener('mouseup', () => {
                btn.style.transform = 'scale(1)';
            });

            btn.addEventListener('click', onClick);
            return btn;
        }

        // Use attack function
        function useAttack(attackName) {
            console.log(`Attempting to use attack: ${attackName}`);

            // Check WebSocket connection
            if (!wsClient.connected) {
                showGameMessage('❌ Not connected to server! Please join a game first.', 3000);
                return;
            }

            // Check if game is in progress
            if (!wsClient.gameId) {
                showGameMessage('❌ Not in a game! Please join a game first.', 3000);
                return;
            }

            // Check if it's the player's turn
            if (!isMyTurn) {
                showGameMessage('❌ Not your turn!', 2000);
                return;
            }

            console.log(`Sending attack: ${attackName}`);
            const success = wsClient.send('use_attack', { attackName: attackName });

            if (success) {
                showGameMessage(`⚔️ Using ${attackName}...`, 2000);
            } else {
                showGameMessage('❌ Failed to send attack command!', 3000);
            }
        }

        // Use ability function  
        function useAbility(abilityName) {
            console.log(`Attempting to use ability: ${abilityName}`);

            // Check WebSocket connection
            if (!wsClient.connected) {
                showGameMessage('❌ Not connected to server! Please join a game first.', 3000);
                return;
            }

            // Check if game is in progress
            if (!wsClient.gameId) {
                showGameMessage('❌ Not in a game! Please join a game first.', 3000);
                return;
            }

            // Check if it's the player's turn
            if (!isMyTurn) {
                showGameMessage('❌ Not your turn!', 2000);
                return;
            }

            console.log(`Sending ability: ${abilityName}`);
            const success = wsClient.send('use_ability', { abilityName: abilityName });

            if (success) {
                showGameMessage(`✨ Using ${abilityName}...`, 2000);
            } else {
                showGameMessage('❌ Failed to send ability command!', 3000);
            }
        }

        // Evolution functions
        function checkCanEvolve(evolutionCard) {
            if (!window.currentGame || !window.currentGame.serverGameState || !window.currentGame.serverGameState.yourState) {
                return false;
            }

            const playerState = window.currentGame.serverGameState.yourState;
            const allPokemon = [playerState.activePokemon, ...playerState.bench].filter(card => card !== null);

            // Check if we have any Pokemon that this card can evolve from
            return allPokemon.some(pokemon => pokemon.pokemon === evolutionCard.evolvesFrom);
        }

        function startEvolution(evolutionCard) {
            console.log(`Starting evolution with card: ${evolutionCard.cardName}`);

            // Check WebSocket connection
            if (!wsClient.connected) {
                showGameMessage('❌ Not connected to server! Please join a game first.', 3000);
                return;
            }

            // Check if game is in progress
            if (!wsClient.gameId) {
                showGameMessage('❌ Not in a game! Please join a game first.', 3000);
                return;
            }

            // Check if it's the player's turn
            if (!isMyTurn) {
                showGameMessage('❌ Not your turn!', 2000);
                return;
            }

            // Find valid targets for evolution
            const playerState = window.currentGame.serverGameState.yourState;
            const validTargets = [];

            // Check active Pokemon
            if (playerState.activePokemon && playerState.activePokemon.pokemon === evolutionCard.evolvesFrom) {
                validTargets.push({
                    pokemon: playerState.activePokemon,
                    location: 'active',
                    index: 0,
                    name: `Active ${playerState.activePokemon.cardName}`
                });
            }

            // Check bench Pokemon
            playerState.bench.forEach((pokemon, index) => {
                if (pokemon && pokemon.pokemon === evolutionCard.evolvesFrom) {
                    validTargets.push({
                        pokemon: pokemon,
                        location: 'bench',
                        index: index,
                        name: `Bench ${pokemon.cardName} (slot ${index + 1})`
                    });
                }
            });

            if (validTargets.length === 0) {
                showGameMessage(`❌ No ${evolutionCard.evolvesFrom} found to evolve!`, 3000);
                return;
            }

            // If only one target, evolve automatically
            if (validTargets.length === 1) {
                const target = validTargets[0];
                performEvolution(evolutionCard, target.location, target.index);
                return;
            }

            // Multiple targets - show selection interface
            showEvolutionTargetSelection(evolutionCard, validTargets);
        }

        function showEvolutionTargetSelection(evolutionCard, validTargets) {
            // Create selection modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 20px;
                border-radius: 10px;
                max-width: 400px;
                text-align: center;
            `;

            content.innerHTML = `
                <h3>Choose Pokemon to Evolve</h3>
                <p>Select which ${evolutionCard.evolvesFrom} to evolve into ${evolutionCard.cardName}:</p>
            `;

            validTargets.forEach(target => {
                const btn = document.createElement('button');
                btn.textContent = target.name;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    margin: 10px 0;
                    padding: 10px;
                    background: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                `;
                btn.onclick = () => {
                    modal.remove();
                    performEvolution(evolutionCard, target.location, target.index);
                };
                content.appendChild(btn);
            });

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                margin-top: 10px;
                padding: 10px 20px;
                background: #f44336;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            `;
            cancelBtn.onclick = () => modal.remove();
            content.appendChild(cancelBtn);

            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function performEvolution(evolutionCard, targetLocation, targetIndex) {
            console.log(`Evolving ${targetLocation} Pokemon at index ${targetIndex}`);

            // Find the evolution card index in hand
            const playerState = window.currentGame.serverGameState.yourState;
            const handIndex = playerState.hand.findIndex(card => card.id === evolutionCard.id);

            if (handIndex === -1) {
                showGameMessage('❌ Evolution card not found in hand!', 3000);
                return;
            }

            const success = wsClient.send('evolve_pokemon', {
                evolutionCardIndex: handIndex,
                targetPokemonLocation: targetLocation,
                targetPokemonIndex: targetIndex
            });

            if (success) {
                showGameMessage(`🔄 Evolving to ${evolutionCard.cardName}...`, 2000);
            } else {
                showGameMessage('❌ Failed to send evolution command!', 3000);
            }
        }

        // Check if Pokemon has enough energy for an attack
        function checkCanUseAttack(pokemonData, attack) {
            if (!attack.energyCost || attack.energyCost.length === 0) {
                return true; // No energy required
            }

            const attachedEnergy = pokemonData.attachedEnergy || [];
            const energyCount = {};

            // Count attached energy by type
            attachedEnergy.forEach(energy => {
                const type = energy.energyType || energy.type;
                energyCount[type] = (energyCount[type] || 0) + 1;
            });

            // Count required energy by type
            const requiredEnergy = {};
            attack.energyCost.forEach(type => {
                requiredEnergy[type] = (requiredEnergy[type] || 0) + 1;
            });

            // Create a copy of energyCount to track what's been used
            const availableEnergy = { ...energyCount };

            // First, satisfy all non-colorless energy requirements
            for (const [type, required] of Object.entries(requiredEnergy)) {
                if (type !== 'colorless') {
                    if ((availableEnergy[type] || 0) < required) {
                        return false; // Not enough specific energy type
                    }
                    // Use up the specific energy type
                    availableEnergy[type] -= required;
                }
            }

            // Now handle colorless energy requirements - can use any remaining energy
            const colorlessRequired = requiredEnergy['colorless'] || 0;
            if (colorlessRequired > 0) {
                const totalRemainingEnergy = Object.values(availableEnergy).reduce((sum, count) => sum + count, 0);
                if (totalRemainingEnergy < colorlessRequired) {
                    return false; // Not enough energy for colorless cost
                }
            }

            return true;
        }

        // Show help message
        function showHelpMessage(message) {
            const helpDiv = document.createElement('div');
            helpDiv.className = 'help-message';
            helpDiv.textContent = message;
            helpDiv.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                padding: 8px 12px;
                background: rgba(33, 150, 243, 0.9);
                color: white;
                border-radius: 6px;
                font-size: 12px;
                z-index: 999;
                max-width: 250px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(helpDiv);
        }

        // Set up WebSocket event listeners
        wsClient.on('waiting_for_opponent', (data) => {
            updateConnectionStatus('waiting', 'Waiting for opponent...');
            showGameMessage('Waiting for another player to join...', 5000);
        });

        wsClient.on('game_found', (data) => {
            updateConnectionStatus('connected', 'Connected');
            playerNumberSpan.textContent = data.playerNumber;
            opponentNameSpan.textContent = data.opponent;
            // Update deck builder opponent display if open
            const opponentSpan = document.getElementById('deck-opponent-name');
            if (opponentSpan) opponentSpan.textContent = data.opponent || 'Waiting for opponent...';
            showGameMessage(`Game found! You are Player ${data.playerNumber}. Opponent: ${data.opponent}`);
            // Set up the game
            setupGame(data.playerNumber);
            // Prompt for deck if not already submitted
            if (!deckSubmitted) {
                openDeckBuilder();
            } else {
                wsClient.sendPlayerReady();
            }
        });

        wsClient.on('joined_lobby', (data) => {
            // Show opponent if server provided username in lobby (may be null until other joins)
            const opponentSpan = document.getElementById('deck-opponent-name');
            if (opponentSpan) opponentSpan.textContent = data.opponent || 'Waiting for opponent...';
        });

        wsClient.on('game_start', (data) => {
            showGameMessage('Game started! You can now move your cards.');
            // The game.start() method already initializes drag and drop with game reference
            // and sends initial state for synchronization
            // Initialize deck count displays when game starts
            initializeDeckCounts();
        });

        // Handle game state updates from server
        wsClient.on('game_state_update', (data) => {
            console.log('Received game state update:', data);
            // Data contains { gameState: {...} }, so we need to extract gameState
            const gameState = data.gameState;
            if (window.currentGame && gameState) {
                window.currentGame.updateFromServerState(gameState);

                // Update turn display - turn info is directly in gameState
                updateTurnDisplay({
                    turn: gameState.turn,
                    isYourTurn: gameState.isYourTurn
                });

                // Update deck counts
                updateDeckCounts(gameState);

                // Update prize card displays
                updatePrizeCards(gameState);

                // Update discard pile displays
                updateDiscardPiles(gameState);

                // Show/hide end turn button
                const endTurnBtn = document.getElementById('end-turn-btn') || addEndTurnButton();
                if (gameState.isYourTurn) {
                    endTurnBtn.style.display = 'block';
                } else {
                    endTurnBtn.style.display = 'none';
                }

                // Update action buttons based on active Pokemon
                addActionButtons();
            } else {
                console.error('No currentGame found or no gameState in data:', data);
            }
        });

        // Handle turn changes
        wsClient.on('turn_changed', (data) => {
            console.log('Turn changed:', data);
            const newIsMyTurn = data.currentPlayer === playerNumber;

            // Update global turn state for guiHookUtils.isMyTurn() method
            window.isMyTurn = newIsMyTurn;
            console.log('DEBUG: Set window.isMyTurn to:', window.isMyTurn);

            updateTurnDisplay({
                turn: data.turn,
                isYourTurn: newIsMyTurn
            });

            // Update deck counts if gameState is provided
            if (data.gameState) {
                updateDeckCounts(data.gameState);
                updatePrizeCards(data.gameState);
            }

            // Update drag controls when turn changes
            if (window.currentGame && window.currentGame.guiHook) {
                const turnReason = newIsMyTurn ?
                    'Your turn - you can move cards' :
                    'Opponent\'s turn - wait for your turn';
                window.currentGame.guiHook.setDragEnabled(newIsMyTurn, turnReason);

                // Force reset energy flag when it becomes my turn
                if (newIsMyTurn) {
                    console.log('DEBUG: My turn detected - forcing energy flag reset');
                    window.currentGame.guiHook.onTurnStart();
                }
            }

            showGameMessage(data.message, 3000);
        });

        // Handle action errors
        wsClient.on('action_error', (data) => {
            console.error('Action error from server:', data);
            showGameMessage(`Action failed: ${data.message}`, 5000);
        });

        wsClient.on('move_error', (data) => {
            console.error('Move error from server:', data);
            showGameMessage(`Move error: ${data.message}`, 5000);

            // Rollback the move on client side
            if (window.currentGame && window.currentGame.guiHook && window.currentGame.guiHook.rollbackLastMove) {
                window.currentGame.guiHook.rollbackLastMove();
            }
        });

        wsClient.on('move_success', (data) => {
            console.log('Move confirmed by server:', data);
            // Clear rollback data since move was successful
            if (guiHook) {
                guiHook.lastMove = null;
            }
        });

        wsClient.on('attack_used', (data) => {
            console.log('Attack successful:', data);
            showGameMessage(`${data.attackName} used! ${data.result.message || ''}`, 3000);
        });

        wsClient.on('ability_used', (data) => {
            console.log('Ability successful:', data);
            showGameMessage(`${data.abilityName} activated! ${data.result.message || ''}`, 3000);
        });

        wsClient.on('action_error', (data) => {
            console.log('Action error:', data);
            showGameMessage(`❌ ${data.message}`, 3000);
        });

        wsClient.on('opponent_disconnected', (data) => {
            updateConnectionStatus('disconnected', 'Opponent disconnected');
            showGameMessage(data.message, 10000);
        });

        // Big game-over modal: show when server signals final game over
        function createGameOverModalIfNeeded() {
            if (document.getElementById('game-over-modal')) return;
            const modal = document.createElement('div');
            modal.id = 'game-over-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.85);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 4000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                text-align: center;
                max-width: 600px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;

            const title = document.createElement('h1');
            title.id = 'game-over-title';
            title.style.margin = '0 0 10px 0';
            title.textContent = 'Game Over';

            const desc = document.createElement('p');
            desc.id = 'game-over-desc';
            desc.style.fontSize = '18px';
            desc.style.margin = '0 0 20px 0';

            const btn = document.createElement('button');
            btn.textContent = 'Return to Lobby';
            btn.style.cssText = `
                padding: 12px 20px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size:16px;
            `;
            btn.onclick = () => {
                // Hide modal and reload page to reset UI / allow rejoin
                modal.style.display = 'none';
                try { wsClient.disconnect(); } catch (e) { }
                // Optionally reload to reset state
                window.location.reload();
            };

            content.appendChild(title);
            content.appendChild(desc);
            content.appendChild(btn);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function showGameOverModal(winnerNumber, winnerName, reason) {
            createGameOverModalIfNeeded();
            const modal = document.getElementById('game-over-modal');
            const title = document.getElementById('game-over-title');
            const desc = document.getElementById('game-over-desc');

            // Build message
            let who = '';
            if (winnerName) who = `${winnerName} (Player ${winnerNumber})`;
            else who = `Player ${winnerNumber}`;

            title.textContent = `${who} wins!`;
            desc.textContent = reason ? `Victory condition: ${reason}` : 'Victory!';

            // Disable action buttons and end-turn UI
            document.querySelectorAll('.action-btn, #end-turn-btn').forEach(el => {
                el.disabled = true;
                el.style.opacity = '0.5';
                el.style.cursor = 'default';
            });

            // Show modal
            modal.style.display = 'flex';
        }

        wsClient.on('game_over', (data) => {
            console.log('GAME OVER message received:', data);
            const { winner, winnerName, reason } = data || {};
            showGameOverModal(winner, winnerName, reason);
        });

        wsClient.on('connection_lost', (data) => {
            updateConnectionStatus('disconnected', 'Connection lost');
            showGameMessage('Lost connection to server. Please refresh to reconnect.', 10000);
        });

        wsClient.on('coin_flip_show', (data) => {
            console.log('Coin flip:', data);
            showCoinFlipToAllClients(data.result, data.player);
        });

        wsClient.on('pokemon_knockout', (data) => {
            console.log('Pokemon knockout:', data);
            const winnerText = data.winner === window.playerNumber ? 'You' : 'Your opponent';

            // Show knockout message
            showGameMessage(`💥 ${data.knockedOutCard.cardName} was knocked out! ${winnerText} drew ${data.prizeCardsDrawn} prize card(s)!`, 5000);

            // Animate prize card taking
            animatePrizeCardTaking(data.winner === window.playerNumber, data.prizeCardsDrawn);
        });

        // Evolution WebSocket handlers
        wsClient.on('evolution_success', (data) => {
            console.log('Evolution successful:', data);
            showGameMessage(`🔄 ${data.message}`, 3000);
        });

        wsClient.on('evolution_error', (data) => {
            console.log('Evolution failed:', data);
            showGameMessage(`❌ Evolution failed: ${data.message}`, 3000);
        });

        function animatePrizeCardTaking(isPlayer, numCards) {
            // Determine which player's prize cards to animate
            const prizeSelector = isPlayer ? '.card.player.prize' : '.card.opp.prize';
            const availablePrizeCards = document.querySelectorAll(prizeSelector);

            // Animate the taking of prize cards one by one (from the end)
            for (let i = 0; i < Math.min(numCards, availablePrizeCards.length); i++) {
                setTimeout(() => {
                    const card = availablePrizeCards[availablePrizeCards.length - 1 - i];
                    if (card) {
                        // Add glow effect before removing
                        card.style.boxShadow = '0 0 20px #FFD700';
                        card.style.transform = 'scale(1.1)';

                        setTimeout(() => {
                            // Animate the card flying away and then remove it
                            card.style.transition = 'all 0.5s ease-out';
                            card.style.transform = 'translateY(-100px) scale(0)';
                            card.style.opacity = '0';

                            // Remove the element after animation
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }, 300);
                    }
                }, i * 200); // Stagger the animations
            }
        }

        wsClient.on('test_result', (data) => {
            console.log('Test result:', data);
            showGameMessage(`🧪 ${data.message}`, 3000);
        });

        // Join game button handler
        joinButton.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            if (!username) {
                alert('Please enter a username');
                return;
            }
            currentUsername = username;
            currentUsernameSpan.textContent = username;
            let connected = false;
            let attempts = 0;
            updateConnectionStatus('connecting', '');
            while (!connected && attempts < 20) { // Try for up to ~1 minute
                try {
                    await wsClient.connect();
                    connected = true;
                } catch (error) {
                    attempts++;
                    updateConnectionStatus('connecting', `(retry ${attempts})`);
                    await new Promise(res => setTimeout(res, 3000));
                }
            }
            if (connected) {
                wsClient.joinGame(username);
                usernameModal.style.display = 'none';
                // Deck builder will open after game_found or deck_required
            } else {
                updateConnectionStatus('disconnected', 'Connection failed');
                alert('Failed to connect to server after multiple attempts. Please try again later.');
            }
        });

        // Enter key handler for username input
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinButton.click();
            }
        });

        // Set up game based on player number
        function setupGame(pNum) {
            playerNumber = pNum; // Store globally for turn management
            window.playerNumber = pNum; // Store for WebSocket handlers

            // Create minimal client objects (server manages all game state)
            player1 = new Client(currentUsername);
            player2 = new Client('Opponent');

            // Create the game with centralized state management
            game = new Game(player1, player2, guiHook);

            // Link the WebSocket client to the game for action handling
            game.wsClient = wsClient;

            // Store game globally for WebSocket handlers
            window.currentGame = game;

            try {
                // Server will send initial game state including decks and hands
                game.start();

                // Initialize deck count displays
                initializeDeckCounts();

                // Add debug helper to window for troubleshooting
                window.debugEnergy = function () {
                    console.log('=== ENERGY DEBUG INFO ===');
                    const handCards = document.querySelectorAll('#PlayerHand .card');
                    console.log('Hand cards found:', handCards.length);

                    handCards.forEach((card, i) => {
                        const cardData = card.cardData || card._cardData;
                        console.log(`Card ${i}:`, cardData);
                        if (cardData && cardData.type === 'energy') {
                            console.log(`  -> Energy card detected: ${cardData.cardName}`);
                        }
                    });

                    const pokemonSlots = document.querySelectorAll('.card.player:not(.empty):not(.hand .card)');
                    console.log('Pokemon slots with cards:', pokemonSlots.length);
                    pokemonSlots.forEach((slot, i) => {
                        console.log(`Pokemon slot ${i}:`, slot);
                    });
                };

                console.log('Game setup complete. Type "debugEnergy()" in console to debug energy attachment issues.');
                console.log('Type "testKnockout()" in console to test the knockout and prize card system.');

            } catch (error) {
                console.error('Error setting up game:', error);
            }
        }

        // Global test function for knockout system
        window.testKnockout = function () {
            if (wsClient && wsClient.socket && wsClient.socket.readyState === WebSocket.OPEN) {
                console.log('Sending knockout test message to server...');
                wsClient.send('test_knockout', {});
            } else {
                console.log('WebSocket not connected');
            }
        };
    </script>
</body>
<script src="Lib/GUI.Demo/BoardDynamicSizing.js"></script>

</html>